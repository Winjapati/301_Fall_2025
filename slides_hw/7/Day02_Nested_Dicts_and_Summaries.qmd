---
title: "Day 2 — Nested Dictionaries & Summaries"
subtitle: "Computation for Linguists • Modeling Hierarchical Data"
author: "Your Name"
format:
  revealjs:
    theme: simple
    slide-number: true
    toc: true
    toc-depth: 2
    code-tools: true
    incremental: false
execute:
  echo: true
  warning: false
  message: false
jupyter: python3
date: 2025-10-24
---

## Plan for the Day

- Nested dictionaries for hierarchical data (language → features)
- Iteration patterns over nested dicts
- Convert nested dicts ↔ DataFrames
- Quick summaries & comparisons

---

## Warm-up (5 min)

**Given:**

```python
phoible = {
    "English": {"stops": 6, "nasals": 3, "fricatives": 9},
    "Hindi":   {"stops": 5, "nasals": 4, "fricatives": 8},
    "Spanish": {"stops": 6, "nasals": 3, "fricatives": 7}
}
```
**Prompt:** How do you get the number of **nasals** in **Hindi**?

```python
phoible["Hindi"]["nasals"]
```

---

## Iterating Through Nested Dicts

```python
for lang, feats in phoible.items():
    total = sum(feats.values())
    print(f"{lang}: total={total}, details={feats}")
```

---

## Nested Dict → DataFrame

```python
import pandas as pd
df = pd.DataFrame(phoible).T  # languages become rows
df["total"] = df.sum(axis=1)
df
```

```python
# Column summaries (means by type)
df.mean(numeric_only=True)
```

---

## Guided Practice (20 min)

**Tasks:**  
1) Add a new feature **"approximants"** to each language (any integer).  
2) Recompute `total`.  
3) Sort by `total` descending.  
4) (Optional) Quick plot.

```python
# Example sketch
df["approximants"] = [2, 3, 2]
df["total"] = df[["stops","nasals","fricatives","approximants"]].sum(axis=1)
df.sort_values("total", ascending=False)
```

```python
# Optional quick bar plot
ax = df[["stops","nasals","fricatives","approximants"]].plot(kind="bar", title="Phoneme Inventory Sizes by Type")
ax.set_xlabel("Language")
ax.set_ylabel("Count")
```

---

## Converting Back (DF → Nested Dict)

```python
nested_back = df[["stops","nasals","fricatives","approximants"]].to_dict(orient="index")
list(nested_back.items())[:2]
```

---

## Applied Linguistics Discussion (10 min)

- Why is a nested dict a good model for typological databases?  
- How might you model **morphological paradigms** or **glossed examples** this way?  
- What are the trade-offs vs. a flat (tidy) table?

---

## Exit Ticket (5 min)

- Create a *new* language entry with your own numbers.  
- Recompute totals and identify which language now has the largest inventory.

```python
# Example: add a language
df.loc["Greek"] = {"stops": 6, "nasals": 2, "fricatives": 9, "approximants": 2, "total": 19}
df.sort_values("total", ascending=False).head()
```

---

## Looking Ahead

- Next: **Lemmatization & Normalization** (tokens → lemmas)  
- You’ll use today’s skills (dicts/DFs) to build **frequency tables** from text.
