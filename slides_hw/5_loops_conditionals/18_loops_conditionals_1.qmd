---
title: "Computation for Linguists"
subtitle: "Beginning Python: Conditionals"
date: "October 6, 2025"
author: "Dr. Andrew M. Byrd"
format:
  revealjs:
    css: header_shrink.css
    theme: beige
    slide-number: true
    center: true
    toc: true
    toc-title: "Plan for the Day"
    toc-depth: 1
editor: visual
---

# Review

-   What did you learn last time?

## Recap from Last Week

-   Three Value Types: **Numbers**, **Strings**, **Boolean**
-   X
-   Y
-   Z

# Loops and Conditionals

- Loops: 
    for loops: do this task for the entire data set
    while loops: do this task as longer as a condition is made.
    
- Conditionals: if this is true, do this.

Loops and Conditionals Control Structures The real power of programming languages comes into play with the use of control structures. Control structures control the flow of a program, telling it what to do next, and in what order. All programming languages use the same basic set of control structures, and just differ in how they're written out. In this module, we'll be learning about the three main kinds of control structures and how they're implemented in python:

Conditionals, or if, else statements for loops while loops Conditionals Conditional statements tell python to do something if some condition is met. For example, we can write a little block of code that will tell us if a number is odd or even. If you divide an even number by 2, it will have no remainder, and if you divide an odd number by 2, it will have a remainder of 1. To get the remainder of division, we can use the % operator.

``` python
100 % 2 \# 0
117 % 2 \# 1
```

We can write a short block of code that will print <x> is even if the number assigned to x is even like so. First, let's assign x = 50 on its own line:

``` python
x = 50 
if x % 2 == 0: print(x, "is even")      # 50 is even
```

Now, we can write our if statement.


Let's break down what's going on here. First, we have a logical statement x % 2 == 0. This statement is checking to see if the outcome of x % 2 is exactly equal to 0. If we run it as its own line of code, we'll get True

``` python
x % 2       # 0
x % 2 == 0  # True 
```

What the `if \<...\>` : part of the code is saying is if the statement that comes between if and the colon : comes back as True, it will do something. In the example above, because the value 50 was assigned to x, then x % 50 == 0 comes back as True, therefore, python will run whatever code comes on the next indented line.

if2.svg

The syntax and formatting of control blocks An important thing to keep straight when programming is which pieces of code should only be run when the if statement is true, and which parts to run no matter what. Every programming language is going to do this a slightly different way. For example, here's how a different programming language, R, does it.

Python already uses curly brackets {} to create dictionaries, so it doesn't use it here. Instead, it uses indentation to define which pieces of code are being controlled by (or, within the "scope" of) the if statement.

```python
if x % 2 == 0: 
    print(x, "is even.") 
    print("This line only prints if it's even too.") 
print("This line prints no matter what.") 
```

If you run this block of code, and x still has the value 50, all three lines will print.

```python
# 50 is even.
# This line only prints if it's even too.
# This line prints no matter what.
```

However, if you change the value assigned to x to an odd number, like 51, and re-run the that block of code, only the last line will be printed.

```python
# This line prints no matter what.
```
This is, in general, how python defines the scope of a control statement.

Lines of code with the same degree of indentation are controlled by the same control structures.

The greater the indentation, the narrower the scope of the code.

Else statements Let's come back to our original if statement.

if x % 2 == 0: print(x, "is even") When x is an even number, this if statement will run the print() command. But when x is an odd number, it doesn't do anything. If we want to print out a statement telling us whether the number is odd, we need to add an additional control structure: else.

An else statement can only come at the end of an if block. If the conditionals above have all been False, python will run whatever code comes after else. Here's how it looks:

if x % 2 == 0: print(x, "is even") else: print(x, "is odd") With this block of code, when x has been assigned 50, python will print 50 is even, and when x has been assigned 51, python will print 51 is odd.

else.svg

Elif There's one last component to our if statements that will fully round them out. Right now, here's the steps that happens in our if block:

It does remainder division of 2 on x. It checks if that result is equal to 0 If that returns True, it prints <x> is even If every condition above returned False, it prints <x> is odd This is going to work for all integers, but let's think about what would happen if we assigned a number with a decimal value, like 50.1 to x.

50.1 divided by 2 has a remainder of 0.1. 0.1 is not equal to 0. 0.1 == 0 returns False, so we don't print anything yet. All the conditions above returned False, so it prints 50.1 is odd. This is not quite right. It seems like what we really want to do is have some kind of check first, to see if the value in x has a decimal value before we do the rest of our even and odd checks.

There are lots of little math tricks we could do to check to see if x has a decimal place, but I think what I'll want to do is check to see of remainder division returns a remainder that is greater than 0 and less than 1.

x = 50.1 x % 1 \> 0 and x % 1 \< 1 So, the start of our if block will start with this decimal check.

if x % 1 \> 0 and x % 1 \< 1: print(x, "is a decimal.") Now we're ready to run our even and odd checks that we worked out before, but we need to do so in a way that tells python that they belong to the same block of checks. We only want python to move on to the even and odd checks if the number is not a decimal. We do this with elif, which is a mashup of else and if. It only runs if the block above was False, and it does its own logical check before running its own code.

Our final block of code to classify numbers into even, odd, or decimals, is:

if x % 1 \> 0 and x % 1 \< 1: print(x, "is a decimal.") elif x % 2 == 0: print(x, "is even") else: print(x, "is odd") Go ahead and check it out with any given number.

elsif-1.svg

More example: Is item in list Let's say we wanted to identify which of the Brontë sisters wrote a particular novel. We'd first need to create a list of novels for each sister.

charlotte = \["The Professor", "Jane Eyre", "Shirley", "Villette"\] emily = \["Wuthering Heights"\] anne = \["Agnes Grey", "The Tenant of Wildfell Hall"\] Now, we can test novel titles against each list.

novel = "Jane Eyre" if novel in charlotte: print("Charlotte Brontë wrote", novel) elif novel in emily: print("Emily Brontë wrote", novel) elif novel in anne: print("Anne Brontë wote", novel) else: print(novel, "was not written by one of the Brontë sisters") More Examples: Counting If we complexify our Brontë checking code, we can also keep track of how many times we've checked whether a particular sister wrote a book. First, we need to initialize a dictionary that will keep track.

bronte_checks = {"charlotte": 0, "emily": 0, "anne" : 0} Now, we include a line of code in each part of the if block to increase the value in the dictionary by 1.

if novel in charlotte: bronte_checks\["charlotte"\] = bronte_checks\["charlotte"\] + 1 print("Charlotte Brontë wrote", novel) elif novel in emily: bronte_checks\["emily"\] = bronte_checks\["emily"\] + 1 print("Emily Brontë wrote", novel) elif novel in anne: bronte_checks\["anne"\] = bronte_checks\["anne"\] + 1 print("Anne Brontë wote", novel) else: print(novel, "was not written by one of the Brontë sisters")
