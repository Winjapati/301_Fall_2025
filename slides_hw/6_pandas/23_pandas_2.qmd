---
title: "Computation for Linguists"
subtitle: "Pandasmonium, Day 2"
date: "October 17, 2025"
author: "Dr. Andrew M. Byrd"
format:
  revealjs:
    css: header_shrink.css
    theme: beige
    slide-number: true
    center: true
    toc: true
    toc-title: "Plan for the Day"
    toc-depth: 1
jupyter: python3
editor: source
---

# Review

-   What did you learn last time?

## Recap from Last Time

-   `pd.Series()`, `pd.DataFrame`
-   Creating `df`
    -   `pd.DataFrame({ column_name : [value_1, value_2] })`
    -   `pd.DataFrame(dict)`
    -   `pd.concat([series_1, series_2], axis=1)`
    -   `pd.DataFrame.from_dict(dict, orient="index", columns=[dict_value])`
    -   `pd.DataFrame(list(dict.items()), columns=[key, value])`

## Review Activity: PIE time

- Using `pd.DataFrame({ ... })`, create the following table

| Root   | Meaning | Latin | Greek    | English |
|:-------|:--------|:------|:---------|:--------|
| *bʰer- | 'to carry'   | ferō  | pʰérō    | bear    |
| *ĝenh₁-  | 'to beget'   | gignō | gígnomai | kin     |
| *ped-  | 'foot'    | pēs   | poús     | foot    |
| *doh₃-   | 'to give'    | dō    | dídōmi   | donate  |

# Indexing and Selecting

## Load up our previous `pd`

``` python
import pandas as pd

fresh_df = pd.DataFrame({
    "language": ["Latin", "Greek", "Sanskrit", "Finnish"],
    "family":   ["Indo-European", "Indo-European", "Indo-European", "Uralic"],
    "speakers_millions": [0, 0, 0, 6],
    "location": ["Italy", "Greece", "India", "Finland"]
})

print(fresh_df)
```

## Inspecting a DataFrame

-   Run this code - what do `.head()`, `.tail()`, `.shape`, `.columns`, and `.index` do?

``` python
df.head(2) 
df.tail(2) 
df.shape
df.columns
df.index
df.info()
```

## Accessing Single Columns

-   We can access a single `.Series()` using `df[ ]`

``` python
df["language"]           # Series
```
- Does this remind you of anything?

## Accessing Multiple Columns

-   Or multiple columns using `df[[ ]]`

``` python
df[["language","family"]] # DataFrame
```

## Selecting Rows by Integer Position

-   We can access specific rows using `df.iloc`
    -   "integer location"

``` python
df.iloc[0]               # first row
df.iloc[1:3]             # slice rows 1..2
```

## Selecting Rows By Label

-   Or rows with a custom index using `df.loc`

``` python
# Rows by label (after we set a custom index)
df2 = df.copy()
df2.index = ["a","b","c","d"]
df2.loc["b"]             # row labeled 'b'
```

## Cell Access (Row + Column)

-   We can access a specific cell by label/column

``` python
df.loc[0, "language"]        # cell by label/column
```

-   Or using `.iloc` with specific coordinates

``` python
df.iloc[0, 0]                # cell by position
```

-   We can also slice in 2D ways:

``` python
df.iloc[0:3, 0:2]            # rows 0..2, cols 0..1
```

## Boolean Filtering

-   And lastly we can filter our table using Boolean operators for specific properties:

``` python
ie = df[df["family"] == "Indo-European"]
ie
```

## Complex Filtering

-   Use the operators `&` (and) and `|` (or)

``` python
df[(df["family"]=="Indo-European") & (df["location"]=="India")]
df[(df["family"]=="Indo-European") | (df["location"]=="Finland")]
```

## Complex Filtering

-   Place `~` in front of the filter to mean **not**

``` python
df[~(df["family"]=="Indo-European")]
```

## Complex Filtering

-   To sort a `df` alphabetically by a specific `.Series()`, use the method `.sort_values()`

``` python
df.sort_values(["location"])
```

## Counting

-   You can add up the total number of a `.Series()` using the `.sum()` method

``` python
df["speakers_millions"].sum()
```

-   Which you can display as a regular `int` using `int()`:

``` python
int(df["speakers_millions"].sum())
```

## Activity: English Vowels

- Copy the below code, and complete the values for "height", "backness", "tense", and "roundedness"
``` python
import pandas as pd

eng_vowels = pd.DataFrame({
    "symbol": ["i", "ɪ", "e", "ɛ", "æ", "u", "ʊ", "o", "ɔ", "ɑ", "ʌ", "ə"],
    "height": [], #choose from "high", "mid", and "low"
    "backness": [], # choose from "front", "back", and "central"
    "tense":   [], #choose from True or False
    "rounded": [], #choose from True or False
})

eng_vowels
```

## Activity: English Vowels

1.  Filter the `df`: show only **high back rounded vowels**

2.  Negation and slicing: display all vowels that are **not tense**.

3.  Then display only the first three vowels of that group.

4.  Sort the `df` by **height** and **backness**.

5.  Count how many vowels are **rounded**, **tense** and **both**.


# Activity Answers

## Review Activity

```python
import pandas as pd

roots = {
    "Root": ["*bher-", "*gen-", "*ped-", "*dō-"],
    "Meaning": ["carry", "beget", "foot", "give"],
    "Latin": ["fero", "gigno", "pes", "do"],
    "Greek": ["phérō", "gígnomai", "poús", "dídōmi"],
    "English": ["bear", "kin", "foot", "donate"]
}

pie_df = pd.DataFrame(roots)
print(pie_df)
```

## Activity: English Vowels

``` python
import pandas as pd

eng_vowels = pd.DataFrame({
    "symbol": ["i", "ɪ", "e", "ɛ", "æ", "u", "ʊ", "o", "ɔ", "ɑ", "ʌ", "ə"],
    "height": ["high", "high", "mid", "mid", "low", "high", "high", "mid", "mid", "low", "mid", "mid"],
    "backness": ["front", "front", "front", "front", "front",
                 "back", "back", "back", "back", "back",
                 "central", "central"],
    "tense":   [True, False, True, False, False,
                True, False, True, False, False,
                False, False],
    "rounded": [False, False, False, False, False,
                True, True, True, True, False,
                False, False]
})
```

## Activity: English Vowels

``` python
import pandas as pd

# 1. Filter the `df`: show only **high back rounded vowels**
eng_vowels[(eng_vowels["height"]=="high") & (eng_vowels["backness"]=="back") & (eng_vowels["rounded"] == True)]
# 2. Negation and slicing: display all vowels that are **not tense**. 
eng_vowels[~(eng_vowels["tense"]==True)]
# 3. Then display only the first three vowels of that group.
eng_vowels[~(eng_vowels["tense"]==True)].head(3)
# 4. Sort the `df` by **height** and **backness**. 
eng_vowels.sort_values(["height", "backness"])
# 5. Count how many vowels are rounded, tense or both.
rounded = eng_vowels["rounded"].sum()
tense = eng_vowels["tense"].sum()
both = (eng_vowels["rounded"] & eng_vowels["tense"]).sum()
print("Rounded:", rounded, "| Tense:", tense, "| Both:", both)
```
